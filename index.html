<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Game puzzle</title>
  <style>
    body {
      background: #222;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      padding: 20px 0;
    }
    #puzzle {
      border: none;
      cursor: pointer;
      max-width: 100%;
      touch-action: none;
      background: #222;
      display: block;
      margin: 10px auto 0 auto;
    }
    #info {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Game puzzle</h1>
  <p>Enjoy the game</p>

  <canvas id="puzzle"></canvas>
  <div id="info"></div>

  <script>
    const ROWS = 6;
    const COLS = 8;

    const canvas = document.getElementById('puzzle');
    const ctx = canvas.getContext('2d');
    const info = document.getElementById('info');

    // áº£nh puzzle vÃ  áº£nh khung
    const puzzleImg = new Image();
    const frameImg  = new Image();
    puzzleImg.src = 'puzzle.jpg';
    frameImg.src  = 'f1.png'; // khung gá»— cá»§a báº¡n

    // VÃ™NG TRáº®NG BÃŠN TRONG KHUNG (báº¡n Ä‘o tá»« Photopea)
    const FRAME_INNER_X = 99;
    const FRAME_INNER_Y = 96;
    const FRAME_INNER_W = 868;
    const FRAME_INNER_H = 602;

    let tileW, tileH;
    let pieces = [];
    let draggingIndex = null;
    let draggingPiece = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let snapTolerance = 0;

    let boardCanvas, boardCtx;
    let boardWidth, boardHeight;
    let boardOffsetX, boardOffsetY;

    let frameWidth, frameHeight;

    let trayStartX, trayStartY;
    let trayCols, trayRows;
    const trayGapX = 4;
    const trayGapY = 4;

    function createPiecePath(ctx, edges) {
      const w = tileW;
      const h = tileH;
      const knob = Math.min(w, h) / 4;

      ctx.moveTo(0, 0);

      if (edges.top === 0) {
        ctx.lineTo(w, 0);
      } else {
        const dir = edges.top;
        const x1 = w / 3;
        const x2 = w / 2;
        const x3 = 2 * w / 3;
        ctx.lineTo(x1, 0);
        ctx.quadraticCurveTo(x2, -dir * knob, x3, 0);
        ctx.lineTo(w, 0);
      }

      if (edges.right === 0) {
        ctx.lineTo(w, h);
      } else {
        const dir = edges.right;
        const y1 = h / 3;
        const y2 = h / 2;
        const y3 = 2 * h / 3;
        ctx.lineTo(w, y1);
        ctx.quadraticCurveTo(w + dir * knob, y2, w, y3);
        ctx.lineTo(w, h);
      }

      if (edges.bottom === 0) {
        ctx.lineTo(0, h);
      } else {
        const dir = edges.bottom;
        const x3 = 2 * w / 3;
        const x2 = w / 2;
        const x1 = w / 3;
        ctx.lineTo(x3, h);
        ctx.quadraticCurveTo(x2, h + dir * knob, x1, h);
        ctx.lineTo(0, h);
      }

      if (edges.left === 0) {
        ctx.lineTo(0, 0);
      } else {
        const dir = edges.left;
        const y3 = 2 * h / 3;
        const y2 = h / 2;
        const y1 = h / 3;
        ctx.lineTo(0, y3);
        ctx.quadraticCurveTo(-dir * knob, y2, 0, y1);
        ctx.lineTo(0, 0);
      }

      ctx.closePath();
    }

    function initPieces() {
      pieces = [];
      const grid = [];

      for (let row = 0; row < ROWS; row++) {
        grid[row] = [];
        for (let col = 0; col < COLS; col++) {
          const correctX = boardOffsetX + col * tileW;
          const correctY = boardOffsetY + row * tileH;

          let top, left, right, bottom;

          if (row === 0) top = 0;
          else top = -grid[row - 1][col].edges.bottom;

          if (col === 0) left = 0;
          else left = -grid[row][col - 1].edges.right;

          if (col === COLS - 1) right = 0;
          else right = Math.random() > 0.5 ? 1 : -1;

          if (row === ROWS - 1) bottom = 0;
          else bottom = Math.random() > 0.5 ? 1 : -1;

          const piece = {
            correctX,
            correctY,
            x: correctX,
            y: correctY,
            edges: { top, right, bottom, left },
            locked: false
          };
          grid[row][col] = piece;
        }
      }

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          pieces.push(grid[r][c]);
        }
      }
    }

    function layoutPiecesInTray() {
      for (let i = pieces.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
      }

      pieces.forEach((p, idx) => {
        const r = Math.floor(idx / trayCols);
        const c = idx % trayCols;
        p.x = trayStartX + c * (tileW + trayGapX);
        p.y = trayStartY + r * (tileH + trayGapY);
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // váº½ khung
      ctx.drawImage(
        frameImg,
        0, 0, frameImg.width, frameImg.height,
        0, 0, frameWidth, frameHeight
      );

      // khay máº£nh
      ctx.save();
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1.5;
      const trayWidth = trayCols * (tileW + trayGapX) - trayGapX;
      const trayHeight = trayRows * (tileH + trayGapY) - trayGapY;
      ctx.strokeRect(trayStartX, trayStartY, trayWidth, trayHeight);
      ctx.restore();

      // máº£nh
      pieces.forEach((p, index) => {
        ctx.save();
        ctx.translate(p.x, p.y);

        ctx.beginPath();
        createPiecePath(ctx, p.edges);
        ctx.clip();

        ctx.drawImage(
          boardCanvas,
          boardOffsetX - p.correctX,
          boardOffsetY - p.correctY
        );

        ctx.strokeStyle = p.locked ? '#2b2b2b' : '#3a3a3a';
        ctx.lineWidth = 1.4;
        ctx.stroke();

        if (index === draggingIndex) {
          ctx.strokeStyle = '#d8c16a';
          ctx.lineWidth = 2.2;
          ctx.stroke();
        }

        ctx.restore();
      });
    }

    function getRelativePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    function getPieceIndexAt(x, y) {
      for (let i = pieces.length - 1; i >= 0; i--) {
        const p = pieces[i];
        if (p.locked) continue;

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.beginPath();
        createPiecePath(ctx, p.edges);
        const hit = ctx.isPointInPath(x, y);
        ctx.restore();
        if (hit) return i;
      }
      return -1;
    }

    function checkSolved() {
      return pieces.every(p => p.locked);
    }

    canvas.addEventListener('pointerdown', e => {
      const pos = getRelativePos(e);
      const idx = getPieceIndexAt(pos.x, pos.y);
      if (idx === -1) return;

      draggingIndex = idx;
      draggingPiece = pieces[idx];

      pieces.splice(idx, 1);
      pieces.push(draggingPiece);
      draggingIndex = pieces.length - 1;

      dragOffsetX = pos.x - draggingPiece.x;
      dragOffsetY = pos.y - draggingPiece.y;

      canvas.setPointerCapture(e.pointerId);
      draw();
    });

    canvas.addEventListener('pointermove', e => {
      if (!draggingPiece) return;
      const pos = getRelativePos(e);
      draggingPiece.x = pos.x - dragOffsetX;
      draggingPiece.y = pos.y - dragOffsetY;
      draw();
    });

    canvas.addEventListener('pointerup', e => {
      if (!draggingPiece) return;

      const dx = draggingPiece.x - draggingPiece.correctX;
      const dy = draggingPiece.y - draggingPiece.correctY;
      if (Math.abs(dx) < snapTolerance && Math.abs(dy) < snapTolerance) {
        draggingPiece.x = draggingPiece.correctX;
        draggingPiece.y = draggingPiece.correctY;
        draggingPiece.locked = true;
      }

      draggingPiece = null;
      draggingIndex = null;
      canvas.releasePointerCapture(e.pointerId);

      if (checkSolved()) {
        info.textContent = 'HoÃ n thÃ nh! ðŸŽ‰';
      } else {
        info.textContent = '';
      }
      draw();
    });

    // Ä‘á»£i cáº£ 2 áº£nh load xong rá»“i má»›i start
    let loadedCount = 0;
    function handleImageLoaded() {
      loadedCount++;
      if (loadedCount === 2) startGame();
    }
    puzzleImg.onload = handleImageLoaded;
    frameImg.onload  = handleImageLoaded;

    function startGame() {
      const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 1024;

      // scale khung vá»«a vá»›i mÃ n hÃ¬nh
      const maxFrameWidth = Math.min(viewportWidth * 0.9, 1200);
      const frameScale = Math.min(maxFrameWidth / frameImg.width, 1);
      frameWidth  = frameImg.width  * frameScale;
      frameHeight = frameImg.height * frameScale;

      // vÃ¹ng tráº¯ng bÃªn trong khung sau khi scale
      const innerX = FRAME_INNER_X * frameScale;
      const innerY = FRAME_INNER_Y * frameScale;
      const innerW = FRAME_INNER_W * frameScale;
      const innerH = FRAME_INNER_H * frameScale;

      // scale tranh Ä‘á»ƒ lá»t vá»«a vÃ¹ng tráº¯ng
      const puzzleScale = Math.min(
        innerW / puzzleImg.width,
        innerH / puzzleImg.height
      );
      boardWidth  = puzzleImg.width  * puzzleScale;
      boardHeight = puzzleImg.height * puzzleScale;

      // cÄƒn giá»¯a tranh trong vÃ¹ng tráº¯ng
      boardOffsetX = innerX + (innerW - boardWidth) / 2;
      boardOffsetY = innerY + (innerH - boardHeight) / 2;

      tileW = boardWidth / COLS;
      tileH = boardHeight / ROWS;
      snapTolerance = Math.min(tileW, tileH) / 4;

      // váº½ áº£nh puzzle Ä‘Ã£ scale vÃ o boardCanvas
      boardCanvas = document.createElement('canvas');
      boardCanvas.width  = boardWidth;
      boardCanvas.height = boardHeight;
      boardCtx = boardCanvas.getContext('2d');
      boardCtx.drawImage(
        puzzleImg,
        0, 0, puzzleImg.width, puzzleImg.height,
        0, 0, boardWidth, boardHeight
      );

      // kÃ­ch thÆ°á»›c canvas & khay máº£nh
      canvas.width = frameWidth;

      trayCols = Math.min(
        COLS,
        Math.max(1, Math.floor(canvas.width / (tileW + trayGapX)))
      );
      trayRows = Math.ceil((ROWS * COLS) / trayCols);
      const trayHeight = trayRows * (tileH + trayGapY) - trayGapY;

      canvas.height = frameHeight + 40 + trayHeight;

      trayStartX = (canvas.width - (trayCols * (tileW + trayGapX) - trayGapX)) / 2;
      trayStartY = frameHeight + 30;

      initPieces();
      layoutPiecesInTray();
      draw();
    }
  </script>
</body>
</html>
